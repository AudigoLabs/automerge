use std::{
    collections::{HashMap, HashSet},
    mem,
};

use automerge_protocol as amp;

use crate::{
    internal::{InternalOpType, Key, ObjectId, OpId},
    object_store::ObjState,
    op_handle::OpHandle,
};
use super::PatchWorkshop;

#[derive(Debug, Clone, PartialEq)]
pub(crate) enum PendingDiff {
    SeqInsert(OpHandle, usize, OpId),
    SeqUpdate(OpHandle, usize, OpId),
    SeqRemove(OpHandle, usize),
    Set(OpHandle),
    CursorChange(Key),
}

impl PendingDiff {
    pub fn operation_key(&self) -> Key {
        match self {
            Self::SeqInsert(op, ..) => op.operation_key(),
            Self::SeqUpdate(op, ..) => op.operation_key(),
            Self::SeqRemove(op, ..) => op.operation_key(),
            Self::Set(op) => op.operation_key(),
            Self::CursorChange(k) => k.clone(),
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
pub(crate) struct PendingDiffs(pub(super) HashMap<ObjectId, Vec<PendingDiff>>);

impl PendingDiffs {
    pub(crate) fn new() -> PendingDiffs {
        PendingDiffs(HashMap::new())
    }

    pub(crate) fn append_diffs(&mut self, oid: &ObjectId, mut diffs: Vec<PendingDiff>) {
        self.0.entry(oid.clone()).or_default().append(&mut diffs)
    }

    pub(crate) fn is_empty(&self) -> bool {
        self.0.is_empty()
    }

    pub(crate) fn changed_object_ids(&self) -> impl Iterator<Item = &ObjectId> {
        self.0.keys()
    }

    pub(crate) fn get_mut(&mut self, obj_id: &ObjectId) -> Option<&mut Vec<PendingDiff>> {
        self.0.get_mut(obj_id)
    }

    pub(crate) fn finalize(&mut self, workshop: &dyn PatchWorkshop) -> Option<amp::MapDiff> {
        if self.0.is_empty() {
            return None;
        }

        let mut objs: Vec<_> = self.changed_object_ids().cloned().collect();
        while let Some(obj_id) = objs.pop() {
            let obj = workshop
                .get_obj(&obj_id)
                .expect("missing object when finalizing diffs");
            if let Some(inbound) = obj.inbound.iter().next() {
                if let Some(diffs) = self.0.get_mut(&inbound.obj) {
                    diffs.push(PendingDiff::Set(inbound.clone()))
                } else {
                    objs.push(inbound.obj);
                    self.append_diffs(&inbound.obj, vec![PendingDiff::Set(inbound.clone())]);
                }
            }
        }

        if let Some(root) = self.0.remove(&ObjectId::Root) {
            Some(self.gen_map_diff(
                &ObjectId::Root,
                workshop.get_obj(&&ObjectId::Root).expect("no root found"),
                &root,
                workshop,
                amp::MapType::Map,
            ))
        } else {
            Some(amp::MapDiff {
                object_id: amp::ObjectId::Root,
                obj_type: amp::MapType::Map,
                props: HashMap::new(),
            })
        }
    }

    fn gen_obj_diff(&self, obj_id: &ObjectId, workshop: &dyn PatchWorkshop) -> amp::Diff {
        // Safety: the pending diffs we are working with are all generated by
        // the OpSet, we should never have a missing object and if we do
        // there's nothing the user can do about that
        let obj = workshop
            .get_obj(obj_id)
            .expect("Missing object in internal diff");
        if let Some(pending) = self.0.get(obj_id) {
            match obj.obj_type {
                amp::ObjType::Sequence(seq_type) => {
                    amp::Diff::Seq(self.gen_seq_diff(obj_id, obj, &pending, workshop, seq_type))
                }
                amp::ObjType::Map(map_type) => {
                    amp::Diff::Map(self.gen_map_diff(obj_id, obj, &pending, workshop, map_type))
                }
            }
        } else {
            // no changes so just return empty edits or props
            match obj.obj_type {
                amp::ObjType::Map(map_type) => amp::Diff::Map(amp::MapDiff {
                    object_id: workshop.make_external_objid(obj_id),
                    obj_type: map_type,
                    props: HashMap::new(),
                }),
                amp::ObjType::Sequence(seq_type) => amp::Diff::Seq(amp::SeqDiff {
                    object_id: workshop.make_external_objid(obj_id),
                    obj_type: seq_type,
                    edits: Vec::new(),
                }),
            }
        }
    }

    fn gen_seq_diff(
        &self,
        obj_id: &ObjectId,
        obj: &ObjState,
        pending: &[PendingDiff],
        workshop: &dyn PatchWorkshop,
        seq_type: amp::SequenceType,
    ) -> amp::SeqDiff {
        let mut edits = Edits::new();
        // used to ensure we don't generate duplicate patches for some op ids (added to the pending
        // list to ensure we have a tree for deeper operations)
        let mut seen_op_ids = HashSet::new();
        for pending_edit in pending.iter() {
            match pending_edit {
                PendingDiff::SeqInsert(op, index, opid) => {
                    seen_op_ids.insert(op.id);
                    let value = match op.action {
                        InternalOpType::Set(ref value) => self.gen_value_diff(op, value, workshop),
                        InternalOpType::Make(_) => self.gen_obj_diff(&op.id.into(), workshop),
                        _ => panic!("del or inc found in field operations"),
                    };
                    let op_id = workshop.make_external_opid(&opid);
                    edits.append_edit(amp::DiffEdit::SingleElementInsert {
                        index: *index as u64,
                        elem_id: op_id.clone().into(),
                        op_id,
                        value,
                    });
                }
                PendingDiff::SeqUpdate(op, index, opid) => {
                    seen_op_ids.insert(op.id);
                    let value = match op.action {
                        InternalOpType::Set(ref value) => self.gen_value_diff(op, value, workshop),
                        InternalOpType::Make(_) => self.gen_obj_diff(&op.id.into(), workshop),
                        InternalOpType::Del => {
                            // do nothing
                            continue;
                        }
                        _ => panic!("del or inc found in field operations"),
                    };
                    edits.append_edit(amp::DiffEdit::Update {
                        index: *index as u64,
                        op_id: workshop.make_external_opid(&opid),
                        value,
                    });
                }
                PendingDiff::SeqRemove(op, index) => {
                    seen_op_ids.insert(op.id);

                    edits.append_edit(amp::DiffEdit::Remove {
                        index: (*index) as u64,
                        count: 1,
                    })
                }
                PendingDiff::Set(op) => {
                    if !seen_op_ids.contains(&op.id) {
                        seen_op_ids.insert(op.id);
                        let value = match op.action {
                            InternalOpType::Set(ref value) => {
                                self.gen_value_diff(op, value, workshop)
                            }
                            InternalOpType::Make(_) => self.gen_obj_diff(&op.id.into(), workshop),
                            _ => panic!("del or inc found in field operations"),
                        };
                        edits.append_edit(amp::DiffEdit::Update {
                            index: obj.index_of(op.id).unwrap_or(0) as u64,
                            op_id: workshop.make_external_opid(&op.id),
                            value,
                        })
                    }
                }
                PendingDiff::CursorChange(_) => {
                    panic!("found cursor change pending diff while generating sequence diff")
                }
            }
        }
        amp::SeqDiff {
            object_id: workshop.make_external_objid(obj_id),
            obj_type: seq_type,
            edits: edits.into_vec(),
        }
    }

    fn gen_map_diff(
        &self,
        obj_id: &ObjectId,
        obj: &ObjState,
        pending: &[PendingDiff],
        workshop: &dyn PatchWorkshop,
        map_type: amp::MapType,
    ) -> amp::MapDiff {
        let mut props = HashMap::new();
        // I may have duplicate keys - I do this to make sure I visit each one only once
        let keys: HashSet<_> = pending.iter().map(|p| p.operation_key()).collect();
        for key in keys.iter() {
            let key_string = workshop.key_to_string(key);
            let mut opid_to_value = HashMap::new();
            for op in obj.props.get(&key).iter().flat_map(|i| i.iter()) {
                let link = match op.action {
                    InternalOpType::Set(ref value) => self.gen_value_diff(op, value, workshop),
                    InternalOpType::Make(_) => {
                        // FIXME
                        self.gen_obj_diff(&op.id.into(), workshop)
                    }
                    _ => panic!("del or inc found in field_operations"),
                };
                opid_to_value.insert(workshop.make_external_opid(&op.id), link);
            }
            props.insert(key_string, opid_to_value);
        }
        amp::MapDiff {
            object_id: workshop.make_external_objid(obj_id),
            obj_type: map_type,
            props,
        }
    }

    fn gen_value_diff(
        &self,
        op: &OpHandle,
        value: &amp::ScalarValue,
        workshop: &dyn PatchWorkshop,
    ) -> amp::Diff {
        match value {
            amp::ScalarValue::Cursor(oid) => {
                // .expect() is okay here because we check that the cursr exists at the start of
                // `OpSet::apply_op()`
                amp::Diff::Cursor(workshop.find_cursor(oid).expect("missing cursor"))
            }
            _ => op.adjusted_value().into(),
        }
    }
}

#[derive(Debug)]
pub(crate) struct Edits(Vec<amp::DiffEdit>);

impl Edits {
    pub(crate) fn new() -> Edits {
        Edits(Vec::new())
    }

    /// Append an edit to this sequence, collapsing it into the last edit if possible.
    ///
    /// The collapsing handles conversion of a sequence of inserts to a multi-insert.
    pub(crate) fn append_edit(&mut self, edit: amp::DiffEdit) {
        if let Some(mut last) = self.0.last_mut() {
            match (&mut last, edit) {
                (
                    amp::DiffEdit::SingleElementInsert {
                        index,
                        elem_id,
                        op_id,
                        value: amp::Diff::Value(value),
                    },
                    amp::DiffEdit::SingleElementInsert {
                        index: next_index,
                        elem_id: next_elem_id,
                        op_id: next_op_id,
                        value: amp::Diff::Value(next_value),
                    },
                ) if *index + 1 == next_index
                    && elem_id.as_opid() == Some(op_id)
                    && next_elem_id.as_opid() == Some(&next_op_id)
                    && op_id.delta(&next_op_id, 1) =>
                {
                    *last = amp::DiffEdit::MultiElementInsert {
                        index: *index,
                        elem_id: elem_id.clone(),
                        values: vec![mem::replace(value, amp::ScalarValue::Null), next_value],
                    };
                }
                (
                    amp::DiffEdit::MultiElementInsert {
                        index,
                        elem_id,
                        values,
                    },
                    amp::DiffEdit::SingleElementInsert {
                        index: next_index,
                        elem_id: next_elem_id,
                        op_id,
                        value: amp::Diff::Value(value),
                    },
                ) if *index + (values.len() as u64) == next_index
                    && next_elem_id.as_opid() == Some(&op_id)
                    && elem_id
                        .as_opid()
                        .unwrap()
                        .delta(&op_id, values.len() as u64) =>
                {
                    values.push(value);
                }
                (
                    amp::DiffEdit::Remove { index, count },
                    amp::DiffEdit::Remove {
                        index: new_index,
                        count: new_count,
                    },
                ) if *index == new_index => *count += new_count,
                (_, edit) => self.0.push(edit),
            }
        } else {
            self.0.push(edit)
        }
    }

    pub(crate) fn into_vec(self) -> Vec<amp::DiffEdit> {
        self.0
    }
}
